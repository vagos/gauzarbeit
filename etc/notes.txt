player can enter room
room has things in it 

How would crafting work?
    - command craft
    - takes a list of items from inventory
    - match it to recipe, return item
    - this can be implemented in the scripting side

How will combat work?
    - things have "moves"
    - you pick one of them at random and perform it

ECS

Components:
    - Physical: can be in places, can have things inside it
    - Attacker: can participate in combat
    - Craftable: can be crafted
    - Usable: can be used

Collection of tiny models. These can be used at various points to bring in new content to the game:
 - https://ollama.com/sroecker/nuextract-tiny-v1.5

An event can either signify: 
    - Something that happened in the world
    - An action that some "Thing" initiated

How do we: 
1. Pass this information alongside the other systems
2. Notify them?
3. 

Currently, each Thing can only have one event per tick. 
This simplifies some things because when a user or entity interact with another thing, there is only the notifier that needs to be interoggated 
in order to find more information about the interaction.
That probably means that the Event object needs to be extensible.
Eg. I might use X "lightly" --- the channel for this could be the other properties from the thing. For example, some stat or equipmnt it holds (soft gloves, light-touching)

TODO: Event types should not be an enum OR should at least be extensible from the scripting engine

Find IP:
docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <container_name>
Find container name:
docker ps -a | grep gzrbt


Weather system idea:
```
// scripts/plugins/weather.js
(function () {
  const NS = "weather";
  const STATES = {
    plains: ["clear", "cloudy", "rain"],
    desert: ["clear", "hot", "sandstorm"],
    tundra: ["clear", "snow", "blizzard"],
  };

  // per-room state lives in KV
  function getState(room) {
    const key = `state:${room.x},${room.y}`;
    return kv.get(NS, key) || "clear";
  }
  function setState(room, st) {
    kv.put(NS, `state:${room.x},${room.y}`, st);
  }

  function pick(arr) { return arr[(Math.random() * arr.length) | 0]; }

  // every 120s, advance weather in rooms with players
  setInterval(120, () => {
    const rooms = list_active_rooms(); // engine helper: rooms that have players
    rooms.forEach((room) => {
      const biome = room_get_tag(room, "biome") || "plains";
      const allowed = STATES[biome] || STATES["plains"];
      const prev = getState(room);
      let next = pick(allowed);
      if (next === prev && Math.random() < 0.5) next = pick(allowed);
      if (next !== prev) {
        setState(room, next);
        room_broadcast(room, `The weather shifts to ${next}.\n`);
        // optional: apply modifiers
        room_set_modifier(room, "visibility", next === "blizzard" ? 0.5 : 1.0);
      }
    });
  });

  // when a player enters, tell them the current weather
  on_event("PlayerMove", (ev) => {
    const room = get_room(ev.a);
    const st = getState(room);
    send_message(ev.a, `Current weather: ${st}\n`);
  });
})();
```

Rooms could blacklist systems that they dont want to affect them or provide hints.
Key idea is for system APIs to be discoverable.
